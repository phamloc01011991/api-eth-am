(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Cabin = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
function format(fmt) {
  var re = /(%?)(%([jds]))/g,
    args = Array.prototype.slice.call(arguments, 1);
  if (args.length) {
    fmt = fmt.toString().replace(re, function (match, escaped, ptn, flag) {
      var arg = args.shift();
      switch (flag) {
        case 's':
          arg = '' + arg;
          break;
        case 'd':
          arg = Number(arg);
          break;
        case 'j':
          arg = JSON.stringify(arg);
          break;
      }
      if (!escaped) {
        return arg;
      }
      args.unshift(arg);
      return match;
    });
  }

  // arguments remain after formatting
  if (args.length) {
    fmt = fmt.toString() + ' ' + args.join(' ');
  }

  // update escaped %% values
  fmt = fmt.toString().replace(/%{2,2}/g, '%');
  return '' + fmt;
}
module.exports = format;

},{}],2:[function(require,module,exports){
'use strict';

const isObject = val => Object.prototype.toString.call(val) === '[object Object]';
const get = (obj, parts, length) => {
  for (let i = 0; i < length; i++) {
    if (obj === null) {
      return;
    }
    const v = obj[parts[i]];
    if (v === undefined) {
      return;
    }
    obj = v;
  }
  return obj;
};
module.exports = function (obj, path) {
  let sep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '.';
  if (!isObject(obj) || !path) {
    return obj;
  }
  const parts = Array.isArray(path) ? path : String(path).split(sep);
  const {
    length
  } = parts;
  return length < 2 ? obj[parts[0]] : get(obj, parts, length);
};

},{}],3:[function(require,module,exports){
'use strict';

/* eslint-disable no-continue, eqeqeq */
const isObject = val => typeof val === 'object' || typeof val === 'function';
const isProto = (val, obj) => val == '__proto__' || val == 'constructor' && typeof obj.constructor === 'function';
const set = (obj, parts, length, val) => {
  let tmp = obj;
  let i = 0;
  for (; i < length - 1; i++) {
    const part = parts[i];
    if (isProto(part, tmp)) {
      continue;
    }
    tmp = !isObject(tmp[part]) ? tmp[part] = {} : tmp[part];
  }
  tmp[parts[i]] = val;
  return obj;
};

/**
* Sets nested values on an object using a dot path or custom separator
* @param {Object} obj
* @param {String|Array} path
* @param {Any} val
* @param {String} [sep = '.']
* @returns {Object}
*/
module.exports = function (obj, path, val) {
  let sep = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '.';
  if (!isObject(obj) || !path || !path.length) {
    return obj;
  }
  const parts = Array.isArray(path) ? path : String(path).split(sep);
  if (isProto(parts[0], obj)) {
    return obj;
  }
  const {
    length
  } = parts;
  if (length === 1) {
    obj[parts[0]] = val;
    return obj;
  }
  return set(obj, parts, length, val);
};

},{}],4:[function(require,module,exports){
(function (process){(function (){
"use strict";

// eslint-disable-next-line import/no-unassigned-import
require('console-polyfill');

// eslint-disable-next-line unicorn/prefer-node-protocol
const os = require('os');
const format = require('@ladjs/format-util');
const formatSpecifiers = require('format-specifiers');
const get = require('@strikeentco/get');
const isError = require('iserror');
const isSymbol = require('is-symbol');
const mergeOptions = require('merge-options');
const pMapSeries = require('p-map-series');
const parseAppInfo = require('parse-app-info');
const parseErr = require('parse-err');
const pickDeep = require('pick-deep');
const set = require('@strikeentco/set');
const unset = require('unset-value');
const {
  boolean
} = require('boolean');
const pkg = require('../package.json');
const silentSymbol = Symbol.for('axe.silent');
const omittedLoggerKeys = new Set(['config', 'log']);
const levels = ['trace', 'debug', 'info', 'warn', 'error', 'fatal'];
const aliases = {
  warning: 'warn',
  err: 'error'
};
const levelError = `\`level\` invalid, must be: ${levels.join(', ')}`;
const name = process.env.NODE_ENV === 'development' ? false : process.env.HOSTNAME || os.hostname();

// <https://github.com/sindresorhus/is-plain-obj/blob/main/index.js>
function isPlainObject(value) {
  if (typeof value !== 'object' || value === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value) && !isSymbol(value);
}

// <https://github.com/GeenenTijd/dotify/blob/master/dotify.js>
function dotifyToArray(obj) {
  const res = [];
  function recurse(obj, current) {
    for (const key of Reflect.ownKeys(obj)) {
      const value = obj[key];
      const convertedKey = isSymbol(key) ? Symbol.keyFor(key) || key.description : key;
      const newKey = current ? current + '.' + convertedKey : convertedKey; // joined key with dot
      // if (value && typeof value === 'object' && !(value instanceof Date) && !ObjectID.isValid(value)) {
      if (isPlainObject(value) && res.indexOf(convertedKey) === -1) {
        res.push(convertedKey);
        recurse(value, newKey); // it's a nested object, so do it again
      } else if (res.indexOf(newKey) === -1) {
        res.push(newKey);
      }
    }
  }
  recurse(obj);
  return res;
}

// <https://stackoverflow.com/a/43233163>
function isEmpty(value) {
  return value === undefined || value === null || typeof value === 'object' && Reflect.ownKeys(value).length === 0 || typeof value === 'string' && value.trim().length === 0;
}
function isNull(value) {
  return value === null;
}
function isUndefined(value) {
  return value === undefined;
}
function isObject(value) {
  return typeof value === 'object' && value !== null && !Array.isArray(value);
}
function isString(value) {
  return typeof value === 'string';
}
function isFunction(value) {
  return typeof value === 'function';
}
function getFunction(value) {
  return isFunction(value) ? value : null;
}
class Axe {
  // eslint-disable-next-line complexity
  constructor() {
    var _this = this;
    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const remappedFields = {};
    if (process.env.AXE_REMAPPED_META_FIELDS) {
      const fields = process.env.AXE_REMAPPED_META_FIELDS;
      const arr = fields.split(',').map(v => v.split(':'));
      for (const [prop, value] of arr) {
        remappedFields[prop] = value;
      }
    }

    // envify does not support conditionals well enough so we declare vars outside
    let omittedFields = process.env.AXE_OMIT_META_FIELDS;
    if (typeof omittedFields === 'string') omittedFields = omittedFields.split(',').map(s => s.trim());
    if (!Array.isArray(omittedFields)) omittedFields = [];
    let pickedFields = process.env.AXE_PICK_META_FIELDS;
    if (typeof pickedFields === 'string') pickedFields = pickedFields.split(',').map(s => s.trim());
    if (!Array.isArray(pickedFields)) pickedFields = [];
    this.config = mergeOptions({
      showStack: process.env.AXE_SHOW_STACK ? boolean(process.env.AXE_SHOW_STACK) : true,
      meta: Object.assign({
        show: process.env.AXE_SHOW_META ? boolean(process.env.AXE_SHOW_META) : true,
        remappedFields,
        omittedFields,
        pickedFields,
        cleanupRemapping: true,
        hideHTTP: 'is_http',
        // implemented mainly for @ladjs/graceful to
        // suppress unnecessary meta output to console
        hideMeta: 'hide_meta'
      }, typeof config.meta === 'object' ? config.meta : {}),
      version: pkg.version,
      silent: false,
      logger: console,
      name,
      level: 'info',
      levels: ['info', 'warn', 'error', 'fatal'],
      appInfo: process.env.AXE_APP_INFO ? boolean(process.env.AXE_APP_INFO) : true,
      hooks: Object.assign({
        pre: [],
        post: []
      }, typeof config.hooks === 'object' ? config.hooks : {})
    }, config);
    this.appInfo = this.config.appInfo ? isFunction(parseAppInfo) ? parseAppInfo() : false : false;
    this.log = this.log.bind(this);

    // Inherit methods from parent logger
    const methods = Object.keys(this.config.logger).filter(key => !omittedLoggerKeys.has(key));
    for (const element of methods) {
      this[element] = this.config.logger[element];
    }

    // Bind helper functions for each log level
    for (const element of levels) {
      // Ensure function exists in logger passed
      if (element === 'fatal') {
        this.config.logger.fatal = getFunction(this.config.logger[element]) || getFunction(this.config.logger.error) || getFunction(this.config.logger.info) || getFunction(this.config.logger.log);
      } else {
        this.config.logger[element] = getFunction(this.config.logger[element]) || getFunction(this.config.logger.info) || getFunction(this.config.logger.log);
      }
      if (!isFunction(this.config.logger[element])) {
        throw new Error(`\`${element}\` must be a function on the logger.`);
      }

      // Bind log handler which normalizes args and populates meta
      this[element] = function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return _this.log(element, ...Array.prototype.slice.call(args));
      };
    }
    this.setLevel = this.setLevel.bind(this);
    this.getNormalizedLevel = this.getNormalizedLevel.bind(this);
    this.setName = this.setName.bind(this);

    // Set the logger name
    if (this.config.name) this.setName(this.config.name);

    // Set the logger level
    this.setLevel(this.config.level);

    // Aliases
    this.err = this.error;
    this.warning = this.warn;

    // Pre and Post Hooks
    this.pre = function (level, fn) {
      this.config.hooks.pre.push(function (_level) {
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }
        if (level !== _level) return [...args];
        return fn(...args);
      });
    };
    this.post = function (level, fn) {
      this.config.hooks.post.push(function (_level) {
        for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
          args[_key3 - 1] = arguments[_key3];
        }
        if (level !== _level) return [...args];
        return fn(...args);
      });
    };
  }
  setLevel(level) {
    if (!isString(level) || levels.indexOf(level) === -1) throw new Error(levelError);
    // Support signale logger and other loggers that use `logLevel`
    if (isString(this.config.logger.logLevel)) this.config.logger.logLevel = level;else this.config.logger.level = level;
    // Adjusts `this.config.levels` array
    // so that it has all proceeding (inclusive)
    this.config.levels = levels.slice(levels.indexOf(level));
  }
  getNormalizedLevel(level) {
    if (!isString(level)) return 'info';
    if (isString(aliases[level])) return aliases[level];
    if (levels.indexOf(level) === -1) return 'info';
    return level;
  }
  setName(name) {
    if (!isString(name)) throw new Error('`name` must be a String');
    // Support signale logger and other loggers that use `scope`
    if (isString(this.config.logger.scope)) this.config.logger.scope = name;else this.config.logger.name = name;
  }

  // eslint-disable-next-line complexity
  log(level, message, meta) {
    const originalArgs = [];
    const errors = [];
    let hasMessage = false;
    let hasLevel = true;
    if (!isUndefined(level)) originalArgs.push(level);
    if (!isUndefined(message)) originalArgs.push(message);
    if (!isUndefined(meta)) originalArgs.push(meta);
    for (var _len4 = arguments.length, args = new Array(_len4 > 3 ? _len4 - 3 : 0), _key4 = 3; _key4 < _len4; _key4++) {
      args[_key4 - 3] = arguments[_key4];
    }
    for (const arg of Array.prototype.slice.call(args)) {
      originalArgs.push(arg);
    }
    let modifier = 0;
    if (isString(level) && isString(aliases[level])) {
      level = aliases[level];
    } else if (isError(level)) {
      hasLevel = false;
      meta = message;
      message = level;
      level = 'error';
    } else if (!isString(level) || levels.indexOf(level) === -1) {
      hasLevel = false;
      meta = message;
      message = level;
      level = this.getNormalizedLevel(level);
      modifier = -1;
    }

    // Return early if it is not a valid logging level
    if (this.config.levels.indexOf(level) === -1) return;

    // Bunyan support (meta, message, ...args)
    let isBunyan = false;
    if ((isObject(message) || Array.isArray(message)) && isString(meta)) {
      isBunyan = true;
      const _meta = meta;
      meta = message;
      message = isString(_meta) && originalArgs.length >= 3 + modifier ? format(...originalArgs.slice(2 + modifier)) : _meta;
    }

    // If message was undefined then set it to level
    if (isUndefined(message)) message = level;

    // If only `message` was passed then if it was an Object
    // preserve it as an Object by setting it as meta
    if (originalArgs.slice(1 + modifier).length === 1 && !isString(message) && !isError(message)) {
      meta = {
        message
      };
      message = level;
    } else if (!isBunyan && originalArgs.length >= 4 + modifier) {
      message = undefined;
      meta = {};
      const messages = [];
      for (const arg of originalArgs.slice(hasLevel && modifier === 0 ? 1 : 0)) {
        if (isError(arg)) errors.push(arg);
        // pushes number, object, string, etc for formatting
        else messages.push(arg);
      }
      if (messages.length > 0) {
        message = format(...messages);
        hasMessage = true;
      }
      if (errors.length > 0 && level === 'log') level = 'error';
    } else if (!isBunyan && originalArgs.length === 3 + modifier && isString(message) && formatSpecifiers.some(t => message.indexOf(t) !== -1)) {
      // Otherwise if there are three args and if the `message` contains
      // a placeholder token (e.g. '%s' or '%d' - see above `formatSpecifiers` variable)
      // then we can infer that the `meta` arg passed is used for formatting
      message = format(message, meta);
      meta = {};
    } else if (!isError(message)) {
      if (isError(meta)) {
        errors.push(meta);
        meta = {};
      } else if (!isObject(meta) && !isUndefined(meta) && !isNull(meta)) {
        // If the `meta` variable passed was not an Object then convert it
        message = format(message, meta);
        meta = {};
      } else if (!isString(message)) {
        // If the message is not a string then we should run `util.format` on it
        // assuming we're formatting it like it was another argument
        // (as opposed to using something like fast-json-stringify)
        message = format(message);
      }
    } else if (isError(meta)) {
      errors.push(meta);
      // handle additional args
      const messages = [];
      if (isError(message)) {
        errors.unshift(message);
        message = undefined;
      }
      for (const arg of originalArgs.slice(2 + modifier)) {
        // should skip this better with slice and modifier adjustment
        if (meta === arg) continue;
        if (isError(arg)) errors.push(arg);else messages.push(arg);
        if (messages.length > 0) {
          message = format(...messages);
          hasMessage = true;
        }
      }
      if (level === 'log') level = 'error';
      meta = {};
    }
    if (!isUndefined(meta) && !isObject(meta)) meta = {
      original_meta: meta
    };else if (!isObject(meta)) meta = {};
    if (isError(message)) {
      errors.unshift(message);
      message = undefined;
    }

    //
    // rewrite `meta.err` to `meta.original_err` for consistency
    // (in case someone has an object with `.err` property on it with an error)
    //
    if (isObject(meta.err)) {
      if (isError(meta.err)) errors.push(meta.err);
      meta.original_err = isError(meta.err) ? parseErr(meta.err) : meta.err;
    }
    let err;
    if (errors.length > 0) {
      if (errors.length === 1) {
        err = errors[0];
      } else {
        err = new Error([...new Set(errors.map(e => e.message).filter(Boolean))].join('; '));
        err.stack = [...new Set(errors.map(e => e.stack).filter(Boolean))].join('\n\n');
        err.errors = errors;
      }
      meta.err = parseErr(err);
      if (!isString(message)) message = err.message;
    }

    //
    // NOTE: this was removed in v10.2.2 due to circular reference issues
    //       (the workaround would involve safeStringify and then JSON.parse which would be perf bloat)
    //       (there still might be another workaround or perhaps we don't add all the args here except additional)
    //
    // Set `args` prop with original arguments passed
    // meta.args = originalArgs;

    // Set default level on meta
    meta.level = level;

    // Add `app` object to metadata
    if (this.appInfo) meta.app = this.appInfo;

    //
    // determine log method to use
    //
    // if we didn't pass a level as a method
    // (e.g. console.info), then we should still
    // use the logger's `log` method to output
    //
    // and fatal should use error (e.g. in browser)
    //
    const method = modifier === -1 ? 'log' : level;

    // pre-hooks
    for (const hook of this.config.hooks.pre) {
      [err, message, meta] = hook(method, err, message, meta);
    }

    //
    // NOTE: using lodash _.omit and _.pick would have been _very slow_
    //
    // const omittedAndPickedFields = {
    //   ..._.omit(meta, this.config.meta.omittedFields),
    //   ..._.pick(meta, this.config.meta.pickedFields)
    // };
    //
    // also we don't want to mutate anything in `meta`
    // and ideally we only want to pick exactly what we need
    // (and not have two operations, one for omit, and one for pick)
    //

    // set a boolean flag if we had the silent symbol or not
    const hadTrueSilentSymbol = boolean(meta[silentSymbol]);
    if (!isEmpty(this.config.meta.remappedFields)) {
      for (const key of Reflect.ownKeys(this.config.meta.remappedFields)) {
        set(meta, this.config.meta.remappedFields[key], get(meta, key));
        unset(meta, key);
        // cleanup empty objects after remapping
        if (this.config.meta.cleanupRemapping) {
          const index = key.lastIndexOf('.');
          if (index === -1) continue;
          const parentKey = key.slice(0, index);
          if (isEmpty(get(meta, parentKey))) unset(meta, parentKey);
        }
      }
    }
    if (!isEmpty(this.config.meta.omittedFields) || !isEmpty(this.config.meta.pickedFields)) {
      const dotified = dotifyToArray(meta);
      // dotified = [
      //   'err.name',
      //   'err.message',
      //   'err.stack',
      //   'level',
      //   'app.name',
      //   'app.version',
      //   'app.node',
      //   'app.hash',
      //   // ...
      // ]

      if (!isEmpty(this.config.meta.omittedFields)) {
        for (const prop of this.config.meta.omittedFields) {
          // <https://stackoverflow.com/a/9882349>
          let i = dotified.length;
          while (i--) {
            if (dotified[i] === prop || !isSymbol(dotified[i]) && dotified[i].indexOf(`${prop}.`) === 0) dotified.splice(i, 1);
          }
        }
      }
      const pickedSymbols = [];
      if (!isEmpty(this.config.meta.pickedFields)) {
        for (const prop of this.config.meta.pickedFields) {
          // response.headers.boop
          // response.headers.beep
          // response.body
          // response.text
          // response
          //
          // so we need to split by the first period and omit any keys from dotified starting with it
          if (isSymbol(prop)) {
            if (meta[prop]) pickedSymbols.push([prop, meta[prop]]);
          } else {
            const index = prop.indexOf('.');
            const key = prop.slice(0, index + 1);
            if (index !== -1) {
              let i = dotified.length;
              while (i--) {
                if (dotified[i] === key.slice(0, -1)) dotified.splice(i, 1);else if (dotified[i].indexOf(key) === 0) dotified.splice(i, 1);
              }
            }
          }

          // finally add it if it did not already exist
          if (dotified.indexOf(prop) === -1) dotified.push(prop);
        }
      }

      //
      // iterate over all dotified values to check for symbols
      //
      // NOTE: this does not take into account that they could already be in `pickedSymbols`
      //       (and it doesn't also do bigints yet)
      //
      for (const prop of dotified) {
        if (isSymbol(prop)) {
          if (meta[prop] !== undefined) pickedSymbols.push([prop, meta[prop]]);
        } else if (meta[Symbol.for(prop)] !== undefined) {
          pickedSymbols.push([Symbol.for(prop), meta[Symbol.for(prop)]]);
        }
      }

      //
      // now we call pick-deep using the final array
      //
      // NOTE: this does not pick symbols, bigints, nor streams
      //       <https://github.com/strikeentco/pick-deep/issues/2>
      //       <https://github.com/strikeentco/pick-deep/issues/2>
      //
      // NOTE: this is wrapped in try/catch in case similar errors occur
      //       <https://github.com/stripe/stripe-node/issues/1796>
      //
      try {
        meta = pickDeep(meta, dotified);
      } catch (err) {
        this.config.logger.error(err);
      }

      //
      // if there were any top-level symbols to be
      // picked then we need to add them back here to the list
      //
      // NOTE: we'd probably want to do the same for bigints as symbols
      //
      if (pickedSymbols.length > 0) {
        for (const [key, value] of pickedSymbols) {
          meta[key] = value;
        }
      }
    }

    // only invoke logger methods if it was not silent
    if (!this.config.silent && !hadTrueSilentSymbol) {
      // Show stack trace if necessary (along with any metadata)
      if (isError(err) && this.config.showStack) {
        if (!this.config.meta.show || isEmpty(meta)) {
          this.config.logger[method](...(hasMessage ? [message, err] : [err]));
        } else if (this.config.meta.hideMeta && meta[this.config.meta.hideMeta]) {
          this.config.logger[method](...(hasMessage ? [message, err] : [err]));
        } else {
          this.config.logger[method](...(hasMessage ? [message, err, meta] : [err, meta]));
        }
      } else if (!this.config.meta.show || isEmpty(meta)) {
        this.config.logger[method](message);
      } else if (this.config.meta.hideMeta && meta[this.config.meta.hideMeta] || this.config.meta.hideHTTP && meta[this.config.meta.hideHTTP]) {
        this.config.logger[method](message);
      } else {
        this.config.logger[method](message, meta);
      }
    }

    // post-hooks
    if (this.config.hooks.post.length === 0) return {
      method,
      err,
      message,
      meta
    };
    return pMapSeries(this.config.hooks.post, hook => hook(method, err, message, meta)).then().catch(err => {
      this.config.logger.error(err);
    });
  }
}
module.exports = Axe;

}).call(this)}).call(this,require('_process'))
},{"../package.json":5,"@ladjs/format-util":1,"@strikeentco/get":2,"@strikeentco/set":3,"_process":28,"boolean":7,"console-polyfill":10,"format-specifiers":11,"is-symbol":19,"iserror":20,"merge-options":23,"os":24,"p-map-series":25,"parse-app-info":9,"parse-err":26,"pick-deep":27,"unset-value":29}],5:[function(require,module,exports){
module.exports={
  "name": "axe",
  "description": "Axe is a logger-agnostic wrapper that normalizes logs regardless of argument style. Great for large development teams, old and new projects, and works with Pino, Bunyan, Winston, console, and more. It is lightweight, performant, highly-configurable, and automatically adds OS, CPU, and Git information to your logs. It supports hooks (useful for masking sensitive data) and dot-notation remapping, omitting, and picking of log metadata properties. Made for Forward Email, Lad, and Cabin.",
  "version": "12.2.6",
  "author": "Nick Baugh <niftylettuce@gmail.com> (http://niftylettuce.com)",
  "browser": {
    "parse-app-info": false
  },
  "bugs": {
    "url": "https://github.com/cabinjs/axe/issues"
  },
  "contributors": [
    "Nick Baugh <niftylettuce@gmail.com> (http://niftylettuce.com)",
    "Alexis Tyler <xo@wvvw.me> (https://wvvw.me/)",
    "shadowgate15 (https://github.com/shadowgate15)",
    "Spencer Snyder <sasnyde2@gmail.com> (https://spencersnyder.io)"
  ],
  "dependencies": {
    "@ladjs/format-util": "^1.0.4",
    "@strikeentco/get": "1.0.1",
    "@strikeentco/set": "1.0.2",
    "boolean": "3.2.0",
    "console-polyfill": "0.3.0",
    "format-specifiers": "^1.0.0",
    "is-symbol": "^1.0.4",
    "iserror": "0.0.2",
    "merge-options": "3.0.4",
    "p-map-series": "2",
    "parse-app-info": "^5.0.0",
    "parse-err": "^1.0.0",
    "pick-deep": "1.0.0",
    "unset-value": "2.0.1"
  },
  "devDependencies": {
    "@babel/cli": "^7.24.1",
    "@babel/core": "^7.24.4",
    "@babel/preset-env": "^7.24.4",
    "@commitlint/cli": "^19.3.0",
    "@commitlint/config-conventional": "^19.2.2",
    "ava": "5.3.1",
    "babelify": "^10.0.0",
    "browserify": "^17.0.0",
    "consola": "^3.2.3",
    "cross-env": "^7.0.3",
    "eslint": "8.49.0",
    "eslint-config-xo-lass": "^2.0.1",
    "eslint-plugin-compat": "^4.2.0",
    "eslint-plugin-node": "^11.1.0",
    "express": "^4.19.2",
    "fixpack": "^4.0.0",
    "husky": "^9.0.11",
    "jsdom": "15.x",
    "koa": "^2.15.3",
    "lint-staged": "^15.2.2",
    "lodash": "^4.17.21",
    "nyc": "^15.1.0",
    "pino": "^9.0.0",
    "remark-cli": "11.0.0",
    "remark-preset-github": "^4.0.4",
    "rimraf": "^5.0.5",
    "signale": "^1.4.0",
    "sinon": "^17.0.1",
    "tinyify": "3.0.0",
    "tsd": "^0.31.0",
    "xo": "0.56.0"
  },
  "engines": {
    "node": ">=14"
  },
  "files": [
    "lib",
    "dist",
    "src"
  ],
  "homepage": "https://github.com/cabinjs/axe",
  "jsdelivr": "dist/axe.min.js",
  "keywords": [
    "airbrake",
    "analytic",
    "analytics",
    "api",
    "axe",
    "bugsnag",
    "bunyan",
    "cabin",
    "cabinjs",
    "chalk",
    "color",
    "colored",
    "connect",
    "console",
    "express",
    "hackable",
    "hapi",
    "koa",
    "lad",
    "ladjs",
    "lass",
    "log",
    "logger",
    "logging",
    "loggly",
    "middleware",
    "official",
    "raven",
    "sentry",
    "signale",
    "timber",
    "transport",
    "winston",
    "wrapper"
  ],
  "license": "MIT",
  "main": "lib/index.js",
  "repository": {
    "type": "git",
    "url": "https://github.com/cabinjs/axe"
  },
  "scripts": {
    "ava": "cross-env NODE_ENV=test ava",
    "browserify": "browserify src/index.js -o dist/axe.js -s Axe -g [ babelify --configFile ./.dist.babelrc.json ]",
    "build": "npm run build:clean && npm run build:lib && npm run build:dist",
    "build:clean": "rimraf lib dist",
    "build:dist": "npm run browserify && npm run minify",
    "build:lib": "babel --config-file ./.lib.babelrc.json src --out-dir lib --copy-files",
    "lint": "xo --fix && remark . -qfo && fixpack",
    "lint-build": "npm run lint-lib && npm run lint-dist",
    "lint-dist": "eslint --no-inline-config -c .dist.eslintrc.json dist",
    "lint-lib": "eslint --no-inline-config -c .lib.eslintrc.json lib",
    "minify": "cross-env NODE_ENV=production browserify src/index.js -o dist/axe.min.js -s Axe -g [ babelify --configFile ./.dist.babelrc.json ] -p tinyify",
    "nyc": "cross-env NODE_ENV=test nyc ava",
    "prepare": "husky install",
    "pretest": "npm run lint",
    "test": "npm run build && npm run lint-build && tsd && npm run nyc"
  },
  "types": "lib/index.d.ts",
  "unpkg": "dist/axe.min.js"
}

},{}],6:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.boolean = void 0;
const boolean = function (value) {
  switch (Object.prototype.toString.call(value)) {
    case '[object String]':
      return ['true', 't', 'yes', 'y', 'on', '1'].includes(value.trim().toLowerCase());
    case '[object Number]':
      return value.valueOf() === 1;
    case '[object Boolean]':
      return value.valueOf();
    default:
      return false;
  }
};
exports.boolean = boolean;

},{}],7:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isBooleanable = exports.boolean = void 0;
const boolean_1 = require("./boolean");
Object.defineProperty(exports, "boolean", {
  enumerable: true,
  get: function () {
    return boolean_1.boolean;
  }
});
const isBooleanable_1 = require("./isBooleanable");
Object.defineProperty(exports, "isBooleanable", {
  enumerable: true,
  get: function () {
    return isBooleanable_1.isBooleanable;
  }
});

},{"./boolean":6,"./isBooleanable":8}],8:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isBooleanable = void 0;
const isBooleanable = function (value) {
  switch (Object.prototype.toString.call(value)) {
    case '[object String]':
      return ['true', 't', 'yes', 'y', 'on', '1', 'false', 'f', 'no', 'n', 'off', '0'].includes(value.trim().toLowerCase());
    case '[object Number]':
      return [0, 1].includes(value.valueOf());
    case '[object Boolean]':
      return true;
    default:
      return false;
  }
};
exports.isBooleanable = isBooleanable;

},{}],9:[function(require,module,exports){

},{}],10:[function(require,module,exports){
// Console-polyfill. MIT license.
// https://github.com/paulmillr/console-polyfill
// Make it safe to do console.log() always.
(function (global) {
  'use strict';

  if (!global.console) {
    global.console = {};
  }
  var con = global.console;
  var prop, method;
  var dummy = function () {};
  var properties = ['memory'];
  var methods = ('assert,clear,count,debug,dir,dirxml,error,exception,group,' + 'groupCollapsed,groupEnd,info,log,markTimeline,profile,profiles,profileEnd,' + 'show,table,time,timeEnd,timeline,timelineEnd,timeStamp,trace,warn').split(',');
  while (prop = properties.pop()) if (!con[prop]) con[prop] = {};
  while (method = methods.pop()) if (!con[method]) con[method] = dummy;
  // Using `this` for web workers & supports Browserify / Webpack.
})(typeof window === 'undefined' ? this : window);

},{}],11:[function(require,module,exports){
// these are known as "placeholder tokens", see this link for more info:
// <https://nodejs.org/api/util.html#util_util_format_format_args>
//
// since they aren't exposed (or don't seem to be) by node (at least not yet)
// we just define an array that contains them for now
// <https://github.com/nodejs/node/issues/17601>
// <https://github.com/nodejs/node/blob/7af1ad0ec15546761233c2e90008316551db2bbd/doc/api/util.md#utilformatformat-args>
module.exports = ['%s', '%d', '%i', '%f', '%j', '%o', '%O', '%%'];

},{}],12:[function(require,module,exports){
/*!
 * get-value <https://github.com/jonschlinkert/get-value>
 *
 * Copyright (c) 2014-2018, Jon Schlinkert.
 * Released under the MIT License.
 */

const isObject = require('isobject');
module.exports = function (target, path, options) {
  if (!isObject(options)) {
    options = {
      default: options
    };
  }
  if (!isValidObject(target)) {
    return typeof options.default !== 'undefined' ? options.default : target;
  }
  if (typeof path === 'number') {
    path = String(path);
  }
  const isArray = Array.isArray(path);
  const isString = typeof path === 'string';
  const splitChar = options.separator || '.';
  const joinChar = options.joinChar || (typeof splitChar === 'string' ? splitChar : '.');
  if (!isString && !isArray) {
    return target;
  }
  if (isString && path in target) {
    return isValid(path, target, options) ? target[path] : options.default;
  }
  let segs = isArray ? path : split(path, splitChar, options);
  let len = segs.length;
  let idx = 0;
  do {
    let prop = segs[idx];
    if (typeof prop === 'number') {
      prop = String(prop);
    }
    while (prop && prop.slice(-1) === '\\') {
      prop = join([prop.slice(0, -1), segs[++idx] || ''], joinChar, options);
    }
    if (prop in target) {
      if (!isValid(prop, target, options)) {
        return options.default;
      }
      target = target[prop];
    } else {
      let hasProp = false;
      let n = idx + 1;
      while (n < len) {
        prop = join([prop, segs[n++]], joinChar, options);
        if (hasProp = prop in target) {
          if (!isValid(prop, target, options)) {
            return options.default;
          }
          target = target[prop];
          idx = n - 1;
          break;
        }
      }
      if (!hasProp) {
        return options.default;
      }
    }
  } while (++idx < len && isValidObject(target));
  if (idx === len) {
    return target;
  }
  return options.default;
};
function join(segs, joinChar, options) {
  if (typeof options.join === 'function') {
    return options.join(segs);
  }
  return segs[0] + joinChar + segs[1];
}
function split(path, splitChar, options) {
  if (typeof options.split === 'function') {
    return options.split(path);
  }
  return path.split(splitChar);
}
function isValid(key, target, options) {
  if (typeof options.isValid === 'function') {
    return options.isValid(key, target);
  }
  return true;
}
function isValidObject(val) {
  return isObject(val) || Array.isArray(val) || typeof val === 'function';
}

},{"isobject":13}],13:[function(require,module,exports){
/*!
 * isobject <https://github.com/jonschlinkert/isobject>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

module.exports = function isObject(val) {
  return val != null && typeof val === 'object' && Array.isArray(val) === false;
};

},{}],14:[function(require,module,exports){
'use strict';

var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = require('./shams');
module.exports = function hasNativeSymbols() {
  if (typeof origSymbol !== 'function') {
    return false;
  }
  if (typeof Symbol !== 'function') {
    return false;
  }
  if (typeof origSymbol('foo') !== 'symbol') {
    return false;
  }
  if (typeof Symbol('bar') !== 'symbol') {
    return false;
  }
  return hasSymbolSham();
};

},{"./shams":15}],15:[function(require,module,exports){
'use strict';

/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
  if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') {
    return false;
  }
  if (typeof Symbol.iterator === 'symbol') {
    return true;
  }
  var obj = {};
  var sym = Symbol('test');
  var symObj = Object(sym);
  if (typeof sym === 'string') {
    return false;
  }
  if (Object.prototype.toString.call(sym) !== '[object Symbol]') {
    return false;
  }
  if (Object.prototype.toString.call(symObj) !== '[object Symbol]') {
    return false;
  }

  // temp disabled per https://github.com/ljharb/object.assign/issues/17
  // if (sym instanceof Symbol) { return false; }
  // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
  // if (!(symObj instanceof Symbol)) { return false; }

  // if (typeof Symbol.prototype.toString !== 'function') { return false; }
  // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

  var symVal = 42;
  obj[sym] = symVal;
  for (sym in obj) {
    return false;
  } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
  if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) {
    return false;
  }
  if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) {
    return false;
  }
  var syms = Object.getOwnPropertySymbols(obj);
  if (syms.length !== 1 || syms[0] !== sym) {
    return false;
  }
  if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
    return false;
  }
  if (typeof Object.getOwnPropertyDescriptor === 'function') {
    var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
    if (descriptor.value !== symVal || descriptor.enumerable !== true) {
      return false;
    }
  }
  return true;
};

},{}],16:[function(require,module,exports){
/*!
 * has-value <https://github.com/jonschlinkert/has-value>
 *
 * Copyright (c) 2014-2018, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

const get = require('get-value');
const has = require('has-values');
module.exports = function (obj, path, options) {
  if (isObject(obj) && (typeof path === 'string' || Array.isArray(path))) {
    return has(get(obj, path, options));
  }
  return false;
};
function isObject(val) {
  return val != null && (typeof val === 'object' || typeof val === 'function' || Array.isArray(val));
}

},{"get-value":12,"has-values":17}],17:[function(require,module,exports){
/*!
 * has-values <https://github.com/jonschlinkert/has-values>
 *
 * Copyright (c) 2014-2018, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

const typeOf = require('kind-of');
module.exports = function has(val) {
  switch (typeOf(val)) {
    case 'boolean':
    case 'date':
    case 'function':
    case 'null':
    case 'number':
      return true;
    case 'undefined':
      return false;
    case 'regexp':
      return val.source !== '(?:)' && val.source !== '';
    case 'buffer':
      return val.toString() !== '';
    case 'error':
      return val.message !== '';
    case 'string':
    case 'arguments':
      return val.length !== 0;
    case 'file':
    case 'map':
    case 'set':
      return val.size !== 0;
    case 'array':
    case 'object':
      for (const key of Object.keys(val)) {
        if (has(val[key])) {
          return true;
        }
      }
      return false;

    // everything else
    default:
      {
        return true;
      }
  }
};

},{"kind-of":22}],18:[function(require,module,exports){
'use strict';

module.exports = value => {
  if (Object.prototype.toString.call(value) !== '[object Object]') {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return prototype === null || prototype === Object.prototype;
};

},{}],19:[function(require,module,exports){
'use strict';

var toStr = Object.prototype.toString;
var hasSymbols = require('has-symbols')();
if (hasSymbols) {
  var symToStr = Symbol.prototype.toString;
  var symStringRegex = /^Symbol\(.*\)$/;
  var isSymbolObject = function isRealSymbolObject(value) {
    if (typeof value.valueOf() !== 'symbol') {
      return false;
    }
    return symStringRegex.test(symToStr.call(value));
  };
  module.exports = function isSymbol(value) {
    if (typeof value === 'symbol') {
      return true;
    }
    if (toStr.call(value) !== '[object Symbol]') {
      return false;
    }
    try {
      return isSymbolObject(value);
    } catch (e) {
      return false;
    }
  };
} else {
  module.exports = function isSymbol(value) {
    // this environment does not support Symbols.
    return false && value;
  };
}

},{"has-symbols":14}],20:[function(require,module,exports){
/**
 * Expose `isError`.
 */

module.exports = isError;

/**
 * Test whether `value` is error object.
 *
 * @param {*} value
 * @returns {boolean}
 */

function isError(value) {
  switch (Object.prototype.toString.call(value)) {
    case '[object Error]':
      return true;
    case '[object Exception]':
      return true;
    case '[object DOMException]':
      return true;
    default:
      return value instanceof Error;
  }
}

},{}],21:[function(require,module,exports){
'use strict';

/*!
 * isobject <https://github.com/jonschlinkert/isobject>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function isObject(val) {
  return val != null && typeof val === 'object' && Array.isArray(val) === false;
}
module.exports = isObject;

},{}],22:[function(require,module,exports){
var toString = Object.prototype.toString;
module.exports = function kindOf(val) {
  if (val === void 0) return 'undefined';
  if (val === null) return 'null';
  var type = typeof val;
  if (type === 'boolean') return 'boolean';
  if (type === 'string') return 'string';
  if (type === 'number') return 'number';
  if (type === 'symbol') return 'symbol';
  if (type === 'function') {
    return isGeneratorFn(val) ? 'generatorfunction' : 'function';
  }
  if (isArray(val)) return 'array';
  if (isBuffer(val)) return 'buffer';
  if (isArguments(val)) return 'arguments';
  if (isDate(val)) return 'date';
  if (isError(val)) return 'error';
  if (isRegexp(val)) return 'regexp';
  switch (ctorName(val)) {
    case 'Symbol':
      return 'symbol';
    case 'Promise':
      return 'promise';

    // Set, Map, WeakSet, WeakMap
    case 'WeakMap':
      return 'weakmap';
    case 'WeakSet':
      return 'weakset';
    case 'Map':
      return 'map';
    case 'Set':
      return 'set';

    // 8-bit typed arrays
    case 'Int8Array':
      return 'int8array';
    case 'Uint8Array':
      return 'uint8array';
    case 'Uint8ClampedArray':
      return 'uint8clampedarray';

    // 16-bit typed arrays
    case 'Int16Array':
      return 'int16array';
    case 'Uint16Array':
      return 'uint16array';

    // 32-bit typed arrays
    case 'Int32Array':
      return 'int32array';
    case 'Uint32Array':
      return 'uint32array';
    case 'Float32Array':
      return 'float32array';
    case 'Float64Array':
      return 'float64array';
  }
  if (isGeneratorObj(val)) {
    return 'generator';
  }

  // Non-plain objects
  type = toString.call(val);
  switch (type) {
    case '[object Object]':
      return 'object';
    // iterators
    case '[object Map Iterator]':
      return 'mapiterator';
    case '[object Set Iterator]':
      return 'setiterator';
    case '[object String Iterator]':
      return 'stringiterator';
    case '[object Array Iterator]':
      return 'arrayiterator';
  }

  // other
  return type.slice(8, -1).toLowerCase().replace(/\s/g, '');
};
function ctorName(val) {
  return typeof val.constructor === 'function' ? val.constructor.name : null;
}
function isArray(val) {
  if (Array.isArray) return Array.isArray(val);
  return val instanceof Array;
}
function isError(val) {
  return val instanceof Error || typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number';
}
function isDate(val) {
  if (val instanceof Date) return true;
  return typeof val.toDateString === 'function' && typeof val.getDate === 'function' && typeof val.setDate === 'function';
}
function isRegexp(val) {
  if (val instanceof RegExp) return true;
  return typeof val.flags === 'string' && typeof val.ignoreCase === 'boolean' && typeof val.multiline === 'boolean' && typeof val.global === 'boolean';
}
function isGeneratorFn(name, val) {
  return ctorName(name) === 'GeneratorFunction';
}
function isGeneratorObj(val) {
  return typeof val.throw === 'function' && typeof val.return === 'function' && typeof val.next === 'function';
}
function isArguments(val) {
  try {
    if (typeof val.length === 'number' && typeof val.callee === 'function') {
      return true;
    }
  } catch (err) {
    if (err.message.indexOf('callee') !== -1) {
      return true;
    }
  }
  return false;
}

/**
 * If you need to support Safari 5-7 (8-10 yr-old browser),
 * take a look at https://github.com/feross/is-buffer
 */

function isBuffer(val) {
  if (val.constructor && typeof val.constructor.isBuffer === 'function') {
    return val.constructor.isBuffer(val);
  }
  return false;
}

},{}],23:[function(require,module,exports){
'use strict';

const isOptionObject = require('is-plain-obj');
const {
  hasOwnProperty
} = Object.prototype;
const {
  propertyIsEnumerable
} = Object;
const defineProperty = (object, name, value) => Object.defineProperty(object, name, {
  value,
  writable: true,
  enumerable: true,
  configurable: true
});
const globalThis = this;
const defaultMergeOptions = {
  concatArrays: false,
  ignoreUndefined: false
};
const getEnumerableOwnPropertyKeys = value => {
  const keys = [];
  for (const key in value) {
    if (hasOwnProperty.call(value, key)) {
      keys.push(key);
    }
  }

  /* istanbul ignore else  */
  if (Object.getOwnPropertySymbols) {
    const symbols = Object.getOwnPropertySymbols(value);
    for (const symbol of symbols) {
      if (propertyIsEnumerable.call(value, symbol)) {
        keys.push(symbol);
      }
    }
  }
  return keys;
};
function clone(value) {
  if (Array.isArray(value)) {
    return cloneArray(value);
  }
  if (isOptionObject(value)) {
    return cloneOptionObject(value);
  }
  return value;
}
function cloneArray(array) {
  const result = array.slice(0, 0);
  getEnumerableOwnPropertyKeys(array).forEach(key => {
    defineProperty(result, key, clone(array[key]));
  });
  return result;
}
function cloneOptionObject(object) {
  const result = Object.getPrototypeOf(object) === null ? Object.create(null) : {};
  getEnumerableOwnPropertyKeys(object).forEach(key => {
    defineProperty(result, key, clone(object[key]));
  });
  return result;
}

/**
 * @param {*} merged already cloned
 * @param {*} source something to merge
 * @param {string[]} keys keys to merge
 * @param {Object} config Config Object
 * @returns {*} cloned Object
 */
const mergeKeys = (merged, source, keys, config) => {
  keys.forEach(key => {
    if (typeof source[key] === 'undefined' && config.ignoreUndefined) {
      return;
    }

    // Do not recurse into prototype chain of merged
    if (key in merged && merged[key] !== Object.getPrototypeOf(merged)) {
      defineProperty(merged, key, merge(merged[key], source[key], config));
    } else {
      defineProperty(merged, key, clone(source[key]));
    }
  });
  return merged;
};

/**
 * @param {*} merged already cloned
 * @param {*} source something to merge
 * @param {Object} config Config Object
 * @returns {*} cloned Object
 *
 * see [Array.prototype.concat ( ...arguments )](http://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.concat)
 */
const concatArrays = (merged, source, config) => {
  let result = merged.slice(0, 0);
  let resultIndex = 0;
  [merged, source].forEach(array => {
    const indices = [];

    // `result.concat(array)` with cloning
    for (let k = 0; k < array.length; k++) {
      if (!hasOwnProperty.call(array, k)) {
        continue;
      }
      indices.push(String(k));
      if (array === merged) {
        // Already cloned
        defineProperty(result, resultIndex++, array[k]);
      } else {
        defineProperty(result, resultIndex++, clone(array[k]));
      }
    }

    // Merge non-index keys
    result = mergeKeys(result, array, getEnumerableOwnPropertyKeys(array).filter(key => !indices.includes(key)), config);
  });
  return result;
};

/**
 * @param {*} merged already cloned
 * @param {*} source something to merge
 * @param {Object} config Config Object
 * @returns {*} cloned Object
 */
function merge(merged, source, config) {
  if (config.concatArrays && Array.isArray(merged) && Array.isArray(source)) {
    return concatArrays(merged, source, config);
  }
  if (!isOptionObject(source) || !isOptionObject(merged)) {
    return clone(source);
  }
  return mergeKeys(merged, source, getEnumerableOwnPropertyKeys(source), config);
}
module.exports = function () {
  const config = merge(clone(defaultMergeOptions), this !== globalThis && this || {}, defaultMergeOptions);
  let merged = {
    _: {}
  };
  for (var _len = arguments.length, options = new Array(_len), _key = 0; _key < _len; _key++) {
    options[_key] = arguments[_key];
  }
  for (const option of options) {
    if (option === undefined) {
      continue;
    }
    if (!isOptionObject(option)) {
      throw new TypeError('`' + option + '` is not an Option Object');
    }
    merged = merge(merged, {
      _: option
    }, config);
  }
  return merged._;
};

},{"is-plain-obj":18}],24:[function(require,module,exports){
exports.endianness = function () {
  return 'LE';
};
exports.hostname = function () {
  if (typeof location !== 'undefined') {
    return location.hostname;
  } else return '';
};
exports.loadavg = function () {
  return [];
};
exports.uptime = function () {
  return 0;
};
exports.freemem = function () {
  return Number.MAX_VALUE;
};
exports.totalmem = function () {
  return Number.MAX_VALUE;
};
exports.cpus = function () {
  return [];
};
exports.type = function () {
  return 'Browser';
};
exports.release = function () {
  if (typeof navigator !== 'undefined') {
    return navigator.appVersion;
  }
  return '';
};
exports.networkInterfaces = exports.getNetworkInterfaces = function () {
  return {};
};
exports.arch = function () {
  return 'javascript';
};
exports.platform = function () {
  return 'browser';
};
exports.tmpdir = exports.tmpDir = function () {
  return '/tmp';
};
exports.EOL = '\n';
exports.homedir = function () {
  return '/';
};

},{}],25:[function(require,module,exports){
'use strict';

const pMapSeries = async (iterable, mapper) => {
  const result = [];
  let index = 0;
  for (const value of iterable) {
    // eslint-disable-next-line no-await-in-loop
    result.push(await mapper(await value, index++));
  }
  return result;
};
module.exports = pMapSeries;
// TODO: Remove this for the next major release
module.exports.default = pMapSeries;

},{}],26:[function(require,module,exports){
"use strict";

function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      var F = function F() {};
      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true,
    didErr = false,
    err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
const isError = require('iserror');

// We want to support parsing other fields than the standard:
// <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors>
// <https://github.com/stripe/stripe-node/blob/3c07d851cf897490d8b93dd4457dda0c4c8e667f/lib/Error.js#L33>
const parseErr = function parseErr(err) {
  let fields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  if (!isError(err)) {
    throw new Error('`err` must be an Error');
  }
  if (!Array.isArray(fields)) {
    throw new TypeError('`fields` must be an Array');
  }
  const keys = {};
  const arr = new Set([...Object.getOwnPropertyNames(Object.getPrototypeOf(err)), ...Object.getOwnPropertyNames(err)]);
  var _iterator = _createForOfIteratorHelper(arr),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      const key = _step.value;
      if (typeof err[key] !== 'function') {
        keys[key] = err[key];
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  if (!keys.name && err.constructor.name) {
    keys.name = err.constructor.name;
  }

  //
  // recursively call parseErr on err.errors if they are errors
  // this is a common approach to combine multiple errors into one error
  // and then add a property called `errors` to the err object with the array of errors
  // (e.g. packages such as `combine-errors` and `maybe-combine-errors` use this approach)
  //
  if (Array.isArray(err.errors)) {
    keys.errors = err.errors.map(e => {
      if (isError(e)) {
        return parseErr(e, fields);
      }
      return e;
    });
  }
  return Array.isArray(fields) && fields.length > 0 ? keys.filter(key => fields.includes(key)) : keys;
};
module.exports = parseErr;

},{"iserror":20}],27:[function(require,module,exports){
'use strict';

const get = require('@strikeentco/get');
const set = require('@strikeentco/set');
const isObject = val => Object.prototype.toString.call(val) === '[object Object]';
const pick = (obj, paths, length, sep) => {
  const picked = {};
  for (let i = 0; i < length; i++) {
    const path = paths[i];
    const val = get(obj, path, sep);
    if (val === undefined) {
      continue; // eslint-disable-line no-continue
    }
    set(picked, path, val, sep);
  }
  return picked;
};
module.exports = function (obj, paths) {
  let sep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '.';
  if (!isObject(obj) || !paths || !(Array.isArray(paths) || typeof paths === 'string')) {
    return {};
  }
  const {
    length
  } = paths;
  if (typeof paths === 'string' || length < 2) {
    const path = typeof paths === 'string' ? paths : paths[0];
    const val = get(obj, path, sep);
    return val !== undefined ? set({}, path, val, sep) : {};
  }
  return pick(obj, paths, length, sep);
};

},{"@strikeentco/get":2,"@strikeentco/set":3}],28:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}
(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  }
  // if setTimeout wasn't available but was latter defined
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  }
  // if clearTimeout wasn't available but was latter defined
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
};

// v8 likes predictible objects
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};
function noop() {}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function (name) {
  return [];
};
process.binding = function (name) {
  throw new Error('process.binding is not supported');
};
process.cwd = function () {
  return '/';
};
process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};
process.umask = function () {
  return 0;
};

},{}],29:[function(require,module,exports){
/*!
 * unset-value <https://github.com/jonschlinkert/unset-value>
 *
 * Copyright (c) 2015, 2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

var isObject = require('isobject');
var has = require('has-value');
const isUnsafeKey = key => {
  return key === '__proto__' || key === 'constructor' || key === 'prototype';
};
const validateKey = key => {
  if (isUnsafeKey(key)) {
    throw new Error(`Cannot set unsafe key: "${key}"`);
  }
};
module.exports = function unset(obj, prop) {
  if (!isObject(obj)) {
    throw new TypeError('expected an object.');
  }
  var isArray = Array.isArray(prop);
  if (!isArray && obj.hasOwnProperty(prop)) {
    delete obj[prop];
    return true;
  }
  if (has(obj, prop)) {
    var segs = isArray ? prop.slice() : prop.split('.');
    var last = segs.pop();
    while (segs.length && segs[segs.length - 1].slice(-1) === '\\') {
      last = segs.pop().slice(0, -1) + '.' + last;
    }
    while (segs.length) {
      prop = segs.shift();
      validateKey(prop);
      obj = obj[prop];
    }
    return delete obj[last];
  }
  return true;
};

},{"has-value":16,"isobject":21}],30:[function(require,module,exports){
module.exports={
  "name": "cabin",
  "description": "Cabin is the best self-hosted JavaScript and Node.js logging service.",
  "version": "13.2.7",
  "author": "Titanism",
  "browser": {
    "./src/middleware": false,
    "./src/message": false,
    "./lib/middleware": false,
    "./lib/message": false
  },
  "bugs": {
    "url": "https://github.com/cabinjs/cabin/issues"
  },
  "contributors": [
    "Titanism"
  ],
  "dependencies": {
    "@ladjs/format-util": "^1.0.4",
    "ansi-colors": "^4.1.3",
    "clf-date": "^0.2.1",
    "format-specifiers": "^1.0.0",
    "iserror": "^0.0.2",
    "merge-options": "^3.0.4",
    "ms": "^2.1.3",
    "on-finished": "^2.4.1",
    "parse-err": "^1.0.0",
    "parse-request": "^6.0.2"
  },
  "devDependencies": {
    "@babel/cli": "^7.24.1",
    "@babel/core": "^7.24.4",
    "@babel/preset-env": "^7.24.4",
    "@commitlint/cli": "^19.3.0",
    "@commitlint/config-conventional": "^19.2.2",
    "ava": "^5.3.1",
    "axe": "^12.2.5",
    "babelify": "^10.0.0",
    "browserify": "^17.0.0",
    "cross-env": "^7.0.3",
    "eslint": "^8.49.0",
    "eslint-config-xo-lass": "^2.0.1",
    "eslint-plugin-compat": "^4.2.0",
    "eslint-plugin-node": "^11.1.0",
    "express": "^4.19.2",
    "express-request-id": "1",
    "fixpack": "^4.0.0",
    "husky": "^9.0.11",
    "jsdom": "15",
    "koa": "^2.15.3",
    "koa-better-request-id": "^1.2.0",
    "koa-better-response-time": "^1.2.0",
    "koa-router": "^12.0.1",
    "lint-staged": "^15.2.2",
    "lodash": "^4.17.21",
    "nyc": "^15.1.0",
    "remark-cli": "^11.0.0",
    "remark-preset-github": "^4.0.4",
    "request-received": "^0.0.3",
    "response-time": "^2.3.2",
    "rimraf": "^5.0.5",
    "signale": "^1.4.0",
    "supertest": "^7.0.0",
    "tinyify": "3.0.0",
    "xo": "^0.56.0"
  },
  "engines": {
    "node": ">=14"
  },
  "files": [
    "lib",
    "dist"
  ],
  "homepage": "https://github.com/cabinjs/cabin",
  "jsdelivr": "dist/cabin.min.js",
  "keywords": [
    "airbrake",
    "analytics",
    "app",
    "boilerplate",
    "bugsnag",
    "bunyan",
    "cabin",
    "chalk",
    "color",
    "colored",
    "console",
    "dashboard",
    "express",
    "framework",
    "frontend",
    "gui",
    "hackable",
    "headers",
    "helper",
    "kit",
    "koa",
    "lad",
    "lass",
    "library",
    "log",
    "logging",
    "logging",
    "loggly",
    "logs",
    "middleware",
    "mongo",
    "mongodb",
    "morgan",
    "object",
    "passport",
    "passportjs",
    "postgres",
    "postgresql",
    "raven",
    "request",
    "sentry",
    "signale",
    "sql",
    "stack",
    "stack-trace",
    "timber",
    "tool",
    "trace",
    "tracekit",
    "transport",
    "user",
    "utility",
    "utility",
    "winston"
  ],
  "license": "MIT",
  "main": "lib/index.js",
  "peerDependencies": {
    "axe": ">= 10.0.0"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/cabinjs/cabin"
  },
  "scripts": {
    "ava": "cross-env NODE_ENV=test ava",
    "browserify": "browserify src/index.js -o dist/cabin.js -s Cabin -g [ babelify --configFile ./.dist.babelrc.json ]",
    "build": "npm run build:clean && npm run build:lib && npm run build:dist",
    "build:clean": "rimraf lib dist",
    "build:dist": "npm run browserify && npm run minify",
    "build:lib": "babel --config-file ./.lib.babelrc.json src --out-dir lib",
    "lint": "xo --fix && remark . -qfo && fixpack",
    "lint-build": "npm run lint-lib && npm run lint-dist",
    "lint-dist": "eslint --no-inline-config -c .dist.eslintrc.json dist",
    "lint-lib": "eslint --no-inline-config -c .lib.eslintrc.json lib",
    "minify": "cross-env NODE_ENV=production browserify src/index.js -o dist/cabin.min.js -s Cabin -g [ babelify --configFile ./.dist.babelrc.json ] -p tinyify",
    "nyc": "cross-env NODE_ENV=test nyc ava",
    "prepare": "husky install",
    "pretest": "npm run lint",
    "test": "npm run build && npm run lint-build && npm run nyc"
  },
  "unpkg": "dist/cabin.min.js"
}

},{}],31:[function(require,module,exports){
const Axe = require('axe');
const format = require('@ladjs/format-util');
const formatSpecifiers = require('format-specifiers');
const isError = require('iserror');
const mergeOptions = require('merge-options');
const parseErr = require('parse-err');
const pkg = require('../package.json');
const {
  isNull,
  isUndefined,
  isObject,
  isString,
  isFunction
} = require('./utils');
const message = require('./message');
const middleware = require('./middleware');
class Cabin {
  constructor(config) {
    var _this = this;
    this.config = mergeOptions({
      logger: console,
      meta: {},
      // <https://github.com/cabinjs/parse-request>
      parseRequest: {},
      // <https://github.com/cabinjs/parse-err>
      errorProps: [],
      // function that accepts (level, req, res) and returns a string
      // (this is consumed by the cabin middleware and not available in browsers)
      message,
      // expose a version for user agent
      version: pkg.version
    }, config);
    if (!isObject(this.config.logger)) throw new Error('Logger option must be a logger object such as `console` or an instance of Axe');
    if (!(this.config.logger instanceof Axe)) this.config.logger = new Axe({
      logger: this.config.logger
    });

    // parse arg helper
    this.parseArg = this.parseArg.bind(this);

    // bind helper functions for each log level
    for (const level of Object.keys(this.config.logger).filter(key => isFunction(this.config.logger[key]))) {
      this[level] = function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        // support format specifiers
        if (typeof args[0] === 'string' && formatSpecifiers.some(t => args[0].includes(t)) && args[1]) {
          args[0] = format(args[0], args[1]);
          delete args[1];
        } else if (args[1]) args[1] = _this.parseArg(args[1]);
        return _this.config.logger[level](...Array.prototype.slice.call(args));
      };
    }

    // aliases
    this.err = this.error;
    this.warning = this.warn;

    // we'd use `auto-bind` package but unfortunately it
    // doesn't have a compiled version without `const` etc
    this.setMeta = this.setMeta.bind(this);
    this.setUser = this.setUser.bind(this);
    if (isFunction(middleware)) this.middleware = middleware.bind(this);
  }
  parseArg() {
    let arg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (isObject(arg)) {
      Object.assign(arg, this.config.meta);
      return arg;
    }
    if (isUndefined(arg) || isNull(arg)) arg = {};else if (isError(arg)) arg = {
      err: parseErr(arg, this.config.errorProps)
    };else if (Array.isArray(arg)) arg = {
      value: arg
    };else if (isString(arg)) arg = {
      value: arg
    };else if (typeof arg === 'number') arg = {
      value: arg
    };else if (isFunction(arg)) arg = {
      value: arg.toString()
    };else arg = {};
    Object.assign(arg, this.config.meta);
    return arg;
  }
  setMeta() {
    let meta = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    this.config.meta = meta;
  }
  setUser() {
    let user = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    this.config.meta.user = user;
  }
}
module.exports = Cabin;

},{"../package.json":30,"./message":9,"./middleware":9,"./utils":32,"@ladjs/format-util":1,"axe":4,"format-specifiers":11,"iserror":20,"merge-options":23,"parse-err":26}],32:[function(require,module,exports){
function isNull(value) {
  return value === null;
}
function isUndefined(value) {
  return value === undefined;
}
function isObject(value) {
  return typeof value === 'object' && value !== null && !Array.isArray(value);
}
function isString(value) {
  return typeof value === 'string';
}
function isFunction(value) {
  return typeof value === 'function';
}
module.exports = {
  isNull,
  isUndefined,
  isObject,
  isString,
  isFunction
};

},{}]},{},[31])(31)
});
